++++++++++++++++++++++++++++++++++++++++
模拟程序结构设计
++++++++++++++++++++++++++++++++++++++++

Monte Carlo模拟程序设计
==============================

主控制类设计
------------------------------

数据：

1. 分级A数列, 保存一系列分级A, 以及其模拟结果数据. 具体实现是一个指针数列, 可以用上C++的多态性;
#. 分级A之间的相关性矩阵 :math:`\Sigma_i` ;
#. 模拟次数等系统参数;

函数:

0. 参数设置函数, 包括从配置文件读取参数, 读取 :math:`\Sigma_i` :math:`R_i` .
1. 迭代模拟路径的函数, 每迭代一步我们需要: 

  a. 生成满足条件的随机向量传给各个分级A对象;
  b. 执行各个分级A的迭代步;

2. 计算总体统计量的函数:

  a. 每个基金的平均第一次下折日;
  b. 第一向上折算日频数分布;
  c. 第一向下折算日频数分布;
  d. 折算日截尾均值;
  e. 折算日25%分位数, 50%分位数, 75%分位数, 与90%分位数;
  f. A基金优先份额久期分析;
  g. 计算隐含收益率;

3. 以合适的格式输出函数, 输出各种数据, 以及统计信息。可以利用MATLAB, R, Python等软件二次处理这些数据, 画图展示. 

分级A虚类设计
------------------------------
考虑到不同的分级A有不同的上下折算规则, 还有不同的定期结算日期. 
需要重载这些功能, 我们设计一个虚类做一个做分级A的类模板. 

数据与参数
``````````````````````````````
模型参数：

1. 母基金净值
#. 母基金预期收益率
#. 基金各项费用
#. 母基金单位净值收益率的年华波动率
#. 进取份额的杠杆倍数
#. A份的约定收益率


数据需要创建一个类来保存一次模拟路径中需要保留下来的数据. 
模拟路径数据类, 包含以下数据:

1. 上折日期数列.
#. 下折日期数列.
#. 各种统计信息(TODO: need more detail)


对于一个虚类中需要保存以下数据:

1. 模拟路径数列
#. 模拟过程中临时保存的母基金价格, A份和B份价格. 
#. 理论价格
#. 各种统计信息(TODO: need more detail)


函数与功能
``````````````````````````````
固定函数, 不需重载, 重复使用:

1. 向前迭代模拟路径: 向前迭代一步模拟路径并保存相关数据. 
#. 计算各种统计信息, 计算理论价格 (TODO: need more detail). 

虚函数, 供继承类根据具体规则重载:

1. 上下折函数
#. 上下折条件
#. 定期折算函数
#. 多次下折后终止条件

QEPM模拟程序设计
========================================

只需要设计一个主类以以 :math:`W, \beta, \Sigma, \Omega, \vec{\mu}` 为输入, 得到输出 :math:`R_i` 与 :math:`\Sigma_i` . 

数据:

1. 输入参数:

   a. :math:`W` 指数权重矩阵;
   b. :math:`\beta` 个股贝塔;
   c. :math:`\Sigma` 个股间的相关矩阵;
   d. :math:`\Omega` 各个因子间的相关矩阵;
   e. :math:`\vec{\mu}` 各个因子的预期值;
   f. 总模拟次数

2. 输出:
 
   a. :math:`R_i`
   b. :math:`\Sigma_i`

3. 辅助变量:
   
   a. :math:`\vec{x}\in N(\vec{\mu}, \Omega)`
   b. :math:`\vec{\epsilon}\in N(0, 1)`

函数:

1. 配置函数, 从配置文件读取输入参数的函数;
2. 生成辅助变量    :math:`\vec{x}\in N(\vec{\mu}, \Omega)` 和 :math:`\vec{\epsilon}\in N(0, 1)` 的函数;
3. 计算输出变量的函数;
4. 输出计算结果的函数;
5. 总体控制函数, 调用上述函数完成计算.

总结
========================================
先运行QEPM的程序, 生成一系列满足条件的 :math:`R_i` 和 :math:`\Sigma_i`. 
然后再在Monte Carlo程序中读入相应 :math:`R_i` 和 :math:`\Sigma_i` 进行后续模拟.

